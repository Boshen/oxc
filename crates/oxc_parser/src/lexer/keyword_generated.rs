use cmov::Cmov;

use crate::lexer::Kind;
#[allow(clippy::enum_glob_use)]
use crate::lexer::Kind::*;

mod hash {
    /// Concatenate the first 2 bytes and the last 2 bytes of a slice into a single
    /// 32-bit integer as an efficient hashing function of JS keywords.
    /// This approach is backed by the observation that the byte-sequence formed by taking
    /// the first 2 and last 2 bytes of JS keywords are unique.
    ///
    /// SAFETY:
    /// key.len() >= 2
    #[inline]
    pub unsafe fn extract_first_and_last_two_bytes(key: &[u8]) -> u32 {
        unsafe fn read_u16(input: &[u8]) -> u16 {
            u16::from(*input.get_unchecked(0)) << 8 | u16::from(*input.get_unchecked(1))
        }
        // read first 2 bytes in a u16
        let first = read_u16(key);
        let last_bytes = &key[key.len() - 2..];
        let last = read_u16(last_bytes);
        u32::from(first) | u32::from(last) << 16
    }

    /// Use a multiplicative linear congruential generator (MLCG) to map the hash value
    /// uniformly. Different values of seed are tested to find one with no collisions.
    #[inline]
    pub fn hash_u32(input: u32, seed: u32) -> u32 {
        // The Magic number is taken from
        // https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf
        const MAGIC: u64 = 887_987_685;
        let hash = input ^ seed;
        ((u64::from(hash) * MAGIC) >> 32) as u32
    }
}

const HASH_TABLE_SIZE: usize = 256usize;
const HASH_TABLE_SEED: u32 = 101_482_731u32;
static KIND_TABLE: [Kind; HASH_TABLE_SIZE] = [
    Target,
    Ident,
    While,
    Default,
    Package,
    Ident,
    Delete,
    Ident,
    Interface,
    Ident,
    Ident,
    Ident,
    As,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Namespace,
    Else,
    Ident,
    Class,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Readonly,
    Ident,
    Ident,
    Ident,
    If,
    Ident,
    Ident,
    Unique,
    Require,
    Catch,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Object,
    Ident,
    Import,
    Ident,
    Ident,
    Ident,
    Symbol,
    Ident,
    Ident,
    Ident,
    Public,
    Ident,
    Ident,
    Ident,
    Ident,
    Declare,
    Ident,
    Debugger,
    Ident,
    Ident,
    Ident,
    Ident,
    False,
    Satisfies,
    Infer,
    Ident,
    With,
    Abstract,
    Ident,
    Ident,
    Get,
    Boolean,
    Ident,
    Ident,
    Never,
    Protected,
    Accessor,
    Number,
    Let,
    Undefined,
    BigInt,
    Ident,
    Ident,
    Any,
    For,
    Ident,
    Super,
    Ident,
    Ident,
    Export,
    Ident,
    Ident,
    Function,
    Ident,
    Ident,
    Enum,
    Unknown,
    Ident,
    Continue,
    Instanceof,
    Ident,
    Ident,
    Override,
    Ident,
    Var,
    Ident,
    Ident,
    Ident,
    Ident,
    From,
    Implements,
    Switch,
    Throw,
    Ident,
    Await,
    Yield,
    Ident,
    Global,
    Ident,
    Ident,
    Ident,
    Private,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    New,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Assert,
    Ident,
    Do,
    Const,
    Ident,
    Ident,
    Ident,
    Meta,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Finally,
    Is,
    Ident,
    Ident,
    Ident,
    Ident,
    Return,
    Ident,
    Case,
    Ident,
    Ident,
    Of,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    In,
    Ident,
    Typeof,
    Try,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Constructor,
    Ident,
    Ident,
    Ident,
    Ident,
    Intrinsic,
    Ident,
    Ident,
    Ident,
    Extends,
    Ident,
    Ident,
    Set,
    Type,
    Ident,
    Ident,
    Async,
    Null,
    Ident,
    Ident,
    String,
    Asserts,
    Ident,
    Ident,
    Ident,
    KeyOf,
    Out,
    Ident,
    Static,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    This,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Ident,
    Module,
    Ident,
    Ident,
    Ident,
    True,
    Void,
    Ident,
    Ident,
    Ident,
    Ident,
    Break,
    Ident,
    Ident,
    Ident,
    Ident,
];
static STR_TABLE: [&'static str; HASH_TABLE_SIZE] = [
    "target",
    "",
    "while",
    "default",
    "package",
    "",
    "delete",
    "",
    "interface",
    "",
    "",
    "",
    "as",
    "",
    "",
    "",
    "",
    "",
    "namespace",
    "else",
    "",
    "class",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "readonly",
    "",
    "",
    "",
    "if",
    "",
    "",
    "unique",
    "require",
    "catch",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "object",
    "",
    "import",
    "",
    "",
    "",
    "symbol",
    "",
    "",
    "",
    "public",
    "",
    "",
    "",
    "",
    "declare",
    "",
    "debugger",
    "",
    "",
    "",
    "",
    "false",
    "satisfies",
    "infer",
    "",
    "with",
    "abstract",
    "",
    "",
    "get",
    "boolean",
    "",
    "",
    "never",
    "protected",
    "accessor",
    "number",
    "let",
    "undefined",
    "bigint",
    "",
    "",
    "any",
    "for",
    "",
    "super",
    "",
    "",
    "export",
    "",
    "",
    "function",
    "",
    "",
    "enum",
    "unknown",
    "",
    "continue",
    "instanceof",
    "",
    "",
    "override",
    "",
    "var",
    "",
    "",
    "",
    "",
    "from",
    "implements",
    "switch",
    "throw",
    "",
    "await",
    "yield",
    "",
    "global",
    "",
    "",
    "",
    "private",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "new",
    "",
    "",
    "",
    "",
    "",
    "assert",
    "",
    "do",
    "const",
    "",
    "",
    "",
    "meta",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "finally",
    "is",
    "",
    "",
    "",
    "",
    "return",
    "",
    "case",
    "",
    "",
    "of",
    "",
    "",
    "",
    "",
    "",
    "",
    "in",
    "",
    "typeof",
    "try",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "constructor",
    "",
    "",
    "",
    "",
    "intrinsic",
    "",
    "",
    "",
    "extends",
    "",
    "",
    "set",
    "type",
    "",
    "",
    "async",
    "null",
    "",
    "",
    "string",
    "asserts",
    "",
    "",
    "",
    "keyof",
    "out",
    "",
    "static",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "this",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "module",
    "",
    "",
    "",
    "true",
    "void",
    "",
    "",
    "",
    "",
    "break",
    "",
    "",
    "",
    "",
];

impl Cmov for Kind {
    fn cmovz(&mut self, value: Self, condition: cmov::Condition) {
        let mut tmp = *self as u8;
        tmp.cmovz(value as u8, condition);
        // SAFETY: Kind is represented as a single u8, and we know that the value is
        // always valid Kind variant
        *self = unsafe { std::mem::transmute(tmp) }
    }

    fn cmovnz(&mut self, _value: Self, _condition: cmov::Condition) {
        unimplemented!()
    }
}

#[inline]
pub fn table_match_keyword(s: &str) -> Kind {
    let slice = s.as_bytes();
    let extract = unsafe { hash::extract_first_and_last_two_bytes(slice) };
    let hash_code = hash::hash_u32(extract, HASH_TABLE_SEED);
    let idx = hash_code as usize % HASH_TABLE_SIZE;
    let mut kind = KIND_TABLE[idx];
    let key = STR_TABLE[idx];
    let condition = u8::from(s.len() == key.len() && s == key);
    kind.cmovz(Ident, condition);
    kind
}
